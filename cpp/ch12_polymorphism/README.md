# Ch12. 다형성 (Polymorphism)
## 01. 다형성이란
> 다형성(polymorphism) : 같은 이름을 갖는 여러 형태의 함수를 클래스별로 만들 수 있게 해주는 기능  

ex. '열다' ➤ '문을 열다', '뚜껑을 열다', '가게를 열다' 등  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ```printArea``` ➤ 삼각형의 넓이 출력, 사각형의 넓이 출력 등

### 1) 다형성 요소
다형성을 구현하기 위해서는 포인터(또는 레퍼런스), 플러그 호환 객체, 가상 함수가 필요하다.  
* 포인터와 레퍼런스  
: C++ 포인터와 레퍼런스는 플러그 예에서 **소켓 역할**을 수행한다. 베이스 클래스를 가리키는 포인터(또는 레퍼런스)를 사용하면 베이스, 파생 클래스 모두를 가리키게 만든다.

* 플러그 호환 객체  
: 상속을 하는 객체들이 램프와 텔레비전 등의 장치 역할인 플러그 호환 객체의 역할을 한다.
* 가상 함수  
: C++ **virtual 키워드를 한정자로 붙인 함수**가 장치들이 자신의 역할을 하기 위해 전달해야 하는 전원의 역할을 한다.
```C++
class Base {
public:
    void print() const { cout << "Base Classs" << endl; }
};

class Derived : 

```
**<span style='background-color: #f6f8fa; color: black'>virtual 한정자 생략</span>**  
virtual 한정자는 베이스 클래스의 멤버 함수에만 붙어 있으면, 이후에 모든 파생 클래스의 멤버함수에도 적용된다. 따라서 파생 클래스 쪽에는 virtual 키워드를 생략해도 된다.

**<span style='background-color: #f6f8fa; color: black'>virtual 매커니즘</span>**  
컴퓨터 시스템은 다형성을 목적으로 클래스 계층이 구성될 때 가상 테이블이라는 것을 만든다. 가상 테이블에 있는 항목들은 가상 함수에 대한 포인터를 갖는다.

### 2) 생성자와 소멸자
#### **□ 가상 생성자도 불가**
생성자도 멤버 함수이지만, 생성자의 이름은 베이스 클래스와 파생 클래스가 무조건 다를 것이므로 가상 클래스 함수가 될 수 없다.
#### **□ 가상 소멸자**
소멸자의 이름도 베이스, 파생 클래스가 각각 다르다. 그러나 소멸자는 이름으로 호철하지 않으므로, **가상 소멸자가 존재한다.** 클래스 설계에서 가상 함수가 있다면 메모리 누수를 피할 수 있게 가상 소멸자를 만들어야 한다.  
case 1) 다형성을 사용하지 않는 경우
case 2) 다형성을 사용하는 경우
#### **□ 다른 프로그래밍 언어의 다형성**

## 02. 추상 클래스와 다중 상속



